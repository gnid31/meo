<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>by gnid31</title>
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif">
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif">
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/fight3.gif">
  <link rel="preload" as="audio" href="https://github.com/gnid31/meo/raw/main/music/happy_birthday.mp3">
  <link rel="preload" as="audio" href="https://github.com/gnid31/meo/raw/main/music/background_music.mp3">
  <link rel="preload" as="fetch" type="text/plain" href="https://raw.githubusercontent.com/gnid31/meo/main/assets.txt">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #FFC0CB;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      color: #333;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 20px;
      box-sizing: border-box;
      overflow: hidden;
      transition: background-image 1s ease-in-out;
    }

    .container {
      background-color: rgba(255, 255, 255, 0.7);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 500px;
      width: 100%;
      position: relative;
      z-index: 10;
    }

    h1 {
      color: #FF69B4;
      margin-top: 0;
      margin-bottom: 25px;
      font-size: 2.5em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      animation: wave 2s ease-in-out infinite alternate;
    }

    audio {
      display: none;
    }

    p {
      font-size: 1.2em;
      line-height: 1.7;
      color: #FF1493;
      margin-top: 20px;
      font-style: italic;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    }

    .snowflake {
      color: #fff;
      font-size: 1.2em;
      position: fixed;
      top: -10px;
      opacity: 0.7;
      user-select: none;
      pointer-events: none;
    }

    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #FFC0CB;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
      text-align: center;
      transition: opacity 0.5s ease-out;
    }

    #splash-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #mystery-text {
      font-size: 3.5em;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
      margin-bottom: 30px;
      animation: bounce 1s infinite alternate;
    }

    @keyframes bounce {
      0% {
        transform: translateY(0);
      }

      100% {
        transform: translateY(-10px);
      }
    }

    #exit-hint {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 1px 1px 3px black;
      z-index: 100001;
      animation: gentleShake 2s infinite ease-in-out;
    }


    #gift-box {
      width: 150px;
      height: 150px;
      margin-bottom: 40px;
      position: relative;
    }

    #claim-button {
      background-color: #FF1493;
      color: white;
      border: none;
      padding: 15px 40px;
      border-radius: 10px;
      font-size: 2em;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, scale 0.2s ease-in-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    #claim-button:hover {
      background-color: #e60073;
      transform: translateY(-2px);
      scale: 1.05;
    }

    #question-box {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      border: 3px solid #FF69B4;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      z-index: 10000;
      transform-origin: center;
    }

    #error-message {
      color: red;
      margin-top: 10px;
      font-weight: bold;
    }

    #attempts-left {
      color: red;
      margin-top: 5px;
    }

    #locked-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10001;
      color: #fff;
      font-size: 2em;
      text-align: center;
      padding: 20px;
      transition: opacity 0.3s ease-in-out;
    }

    #locked-screen .highlight-text {
      font-size: 3em;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 0 0 15px #ff69b4, 0 0 25px #ff1493, 2px 2px 10px rgba(0, 0, 0, 0.7);
      animation: glowText 1.5s ease-in-out infinite alternate;
    }

    #song-buttons {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    #song-buttons button {
      background-color: #FF69B4;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 5px 8px;
      margin: 0;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s ease;
      width: auto;
    }

    #song-buttons button:hover {
      background-color: #e60073;
      transform: scale(1.05);
    }


    @keyframes glowText {
      from {
        text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493;
        transform: scale(1);
      }

      to {
        text-shadow: 0 0 20px #ff69b4, 0 0 30px #ff1493;
        transform: scale(1.05);
      }
    }

    @keyframes gentleShake {
      0% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-2px);
      }

      50% {
        transform: translateX(2px);
      }

      75% {
        transform: translateX(-1px);
      }

      100% {
        transform: translateX(0);
      }
    }

    #locked-screen .f5-hint {
      animation: gentleShake 1s infinite ease-in-out;
      font-size: 0.8em;
      margin-top: 20px;
      color: #fff;
      opacity: 0.9;
    }

    #screensaver {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      z-index: 100000;
      display: none;
      overflow: hidden;
    }

    #screensaver img {
      position: absolute;
      width: 200px;
      height: 200px;
      object-fit: contain;
      pointer-events: none;
    }


    @media (max-width: 600px) {
      .container {
        padding: 25px 30px;
      }

      h1 {
        font-size: 2em;
      }

      p {
        font-size: 1.1em;
      }

      #mystery-text {
        font-size: 2.5em;
      }

      #gift-box {
        width: 120px;
        height: 120px;
      }

      #claim-button {
        font-size: 1.5em;
        padding: 12px 30px;
      }
    }

    @keyframes shake {

      0%,
      100% {
        transform: translate(-50%, -50%);
      }

      10%,
      30%,
      50%,
      70%,
      90% {
        transform: translate(calc(-50% - 5px), calc(-50% - 2px));
      }

      20%,
      40%,
      60%,
      80% {
        transform: translate(calc(-50% + 5px), calc(-50% + 2px));
      }
    }

    .shake {
      animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }

    .popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 10002;
      justify-content: center;
      align-items: center;
    }

    .popup-content {
      background-color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: popupAppear 0.5s ease-out;
      border: 3px solid #FF69B4;
      box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
    }

    .popup-content h2 {
      color: #FF1493;
      margin-bottom: 20px;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    #close-popup {
      background-color: #FF69B4;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.3s ease;
    }

    #close-popup:hover {
      background-color: #FF1493;
      transform: scale(1.05);
    }

    @keyframes popupAppear {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* New CSS for the GIF overlay */
    #error-gif-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent; /* Đã thay đổi từ rgb(255, 255, 255) thành transparent */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10003; /* Above question box */
      pointer-events: none; /* Allow clicks to pass through if needed */
      opacity: 0; /* Initially hidden */
      transition: opacity 0.3s ease-in-out;
    }

    #error-gif-overlay.visible {
      opacity: 1;
    }

    #error-gif {
      width: 700px; /* Adjust size as needed */
      height: 700px; /* Adjust size as needed */
      object-fit: contain; /* Ensure the GIF maintains its aspect ratio while fitting */
      transform: translateY(-100px); /* Move the GIF up by 100px */
    }

    /* New styles for submit-answer button */
    #submit-answer {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #FF69B4;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s ease, background-color 0.3s ease; /* Thêm hiệu ứng chuyển đổi mượt mà */
    }

    #submit-answer:hover:not(:disabled) {
      background-color: #e60073; /* Màu tối hơn khi hover */
      transform: scale(1.05); /* Phồng ra một chút */
    }

    #submit-answer:disabled {
      background-color: #cccccc; /* Màu xám khi bị vô hiệu hóa */
      cursor: not-allowed;
    }

    /* New CSS for success screensaver */
    #success-screensaver {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #FFC0CB; /* Màu hồng phấn */
      display: none; /* Hidden by default */
      overflow: hidden;
      z-index: 9999;
    }

    #success-screensaver .firework-gif {
      position: absolute;
      width: 150px; /* Kích thước cơ bản của GIF pháo hoa */
      height: auto;
      opacity: 0;
      animation: fadeAndMove 6s ease-out forwards; /* Hoạt ảnh fade out và di chuyển */
      pointer-events: none;
    }

    /* NEW CSS for bouncing text on success screensaver */
    #success-screensaver .success-bouncing-text {
      position: absolute;
      font-size: 3em; /* Larger font size for impact */
      font-weight: bold;
      color: white; /* Changed to white for brighter effect */
      text-shadow: 0 0 15px #FF1493, 0 0 25px #FF69B4, 0 0 40px #FFD700; /* Increased shadows for more glow */
      opacity: 0;
      animation: fadeAndMove 6s ease-out forwards; /* Reuse existing animation */
      pointer-events: none;
      white-space: nowrap; /* Prevent text from wrapping */
    }

    /* New styles for success exit hint */
    #success-exit-hint {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 3px black;
      z-index: 100001;
      animation: gentleShake 2s infinite ease-in-out; /* Áp dụng animation gentleShake */
    }

    @keyframes fadeAndMove {
      0% {
        opacity: 0;
        transform: translateY(0) scale(0.5);
      }
      20% {
        opacity: 1;
        transform: translateY(-20px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) scale(0.8);
      }
    }

    /* New CSS for loading screen */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #FFC0CB; /* Màu hồng phấn */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100000; /* Above everything else */
      transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
    }

    #loading-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #loading-cat-gif {
      width: 80px; /* Kích thước của GIF mèo, bạn có thể điều chỉnh */
      height: auto;
      position: absolute; /* Để có thể di chuyển ngang thanh loading */
      top: -80px; /* Đặt GIF ngay phía trên thanh loading (giả sử GIF cao 50px) */
      left: 0; /* Bắt đầu từ bên trái của thanh loading */
      transform: translateX(-50%); /* Canh giữa GIF theo trục X */
      z-index: 100001; /* Đảm bảo GIF nằm trên thanh loading */
    }

    .loading-bar-container {
      width: 80%;
      max-width: 400px;
      height: 20px;
      background-color: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
      overflow: visible; /* Thay đổi từ hidden sang visible để GIF không bị cắt */
      margin-bottom: 10px;
      position: relative; /* RẤT QUAN TRỌNG: Để con của nó (GIF) định vị tương đối */
    }

    .loading-bar {
      height: 100%;
      width: 0%;
      background-color: #FF1493; /* Màu hồng đậm */
      border-radius: 10px;
      transition: width 0.1s linear; /* Hoạt ảnh cho thanh loading */
    }

    .loading-text {
      color: #fff;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
      margin-top: 20px; /* Khoảng cách từ thanh loading */
    }
  </style>
</head>

<body>
  <div id="splash-screen">
    <div id="mystery-text">Mystery Box</div>
    <img id="gift-box"
      src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif"
      alt="Gift Box">
    <button id="claim-button">Unbox</button>
  </div>

  <div id="question-box">
    <div><strong>Câu hỏi bí mật:</strong> Chuỗi đổi màu lúc bao nhiu tủi???</div>
    <input type="text" id="secret-answer" placeholder="Nhập câu trả lời..."
      style="padding: 10px; font-size: 1em; margin-top: 15px; width: 80%;">
    <button id="submit-answer">Trả lời</button>
    <div id="error-message"></div>
    <div id="attempts-left"></div>
    <!-- New GIF overlay -->
    <div id="error-gif-overlay">
      <img id="error-gif" src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif" alt="Error GIF">
    </div>
  </div>

  <div id="locked-screen">
    <div class="highlight-text">
      <div>đáng đánh!!!</div>
    </div>
    <!-- New GIF for locked screen -->
    <img id="fight-gif" src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/fight3.gif" alt="Fight GIF" style="width: 500px; height: auto; margin-top: 30px;">
    <div class="f5-hint">Press F5 to continue opening the Mystery Box</div>
  </div>

  <div class="container">
    <h1>Mèo méo meo mèo me0o0o0!</h1>
    <div id="song-selector">
      <p>🎵 Âm nhạc là music</p>
      <div id="song-buttons">
        <button onclick="playSong(0)">meo 8</button>
        <button onclick="playSong(1)">meo 20</button>
        <button onclick="playSong(2)">meo 7</button>
        <button onclick="playSong(3)">meo 0</button>
        <button onclick="playSong(4)">meo 13</button>
        <button onclick="playSong(5)">meo 6</button>
      </div>
    </div>

    <audio id="myAudio" controls>
      <source id="audio-source" src="" type="audio/mpeg">
      Trình duyệt không hỗ trợ audio.
    </audio>

    <p></p>
  </div>

  <audio id="error-sound" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>

  <!-- New audio for fireworks background music -->
  <audio id="fireworks-music" src="https://github.com/gnid31/meo/raw/main/music/happy_birthday.mp3" loop></audio>

  <!-- New audio for main background music -->
  <audio id="main-background-music" src="https://github.com/gnid31/meo/raw/main/music/background_music.mp3" loop></audio>

  <!-- NEW audio for slaps sound -->
  <audio id="slaps-sound" src="https://github.com/gnid31/meo/raw/main/music/slaps1.mp3" loop></audio>

  <!-- New success screensaver HTML -->
  <div id="success-screensaver">
    <div id="success-exit-hint">Press any key to exit</div>
  </div>

  <!-- New loading screen HTML -->
  <div id="loading-screen">
    <div class="loading-bar-container">
      <img id="loading-cat-gif" src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/cat-ezgif.com-rotate.webp" alt="Loading Cat">
      <div class="loading-bar"></div>
    </div>
    <div class="loading-text">Loading <span id="loading-percentage">0</span>%</div>
  </div>

  <script>
    console.log("Script loaded and starting execution.");

    // const BACKGROUND_IMAGE_URL = "C:/Users/ADMIN/Desktop/meomeo/wallpaper/e82e59a091fccfe88d581ef7dc56f070.jpg";
    let wallpaperImageUrls = []; // New global array for wallpaper image URLs
    let currentBackgroundIndex = 0;
    let backgroundChangeInterval = null; // Biến để lưu trữ interval thay đổi ảnh nền
    let attemptsLeft = 3;
    let fireworkInterval = null;
    let animationInterval = null; // Cần là global để showScreensaver có thể clear nó
    let allowExitSuccessScreen = false; // Khai báo biến cờ mới
    let activeFireworkElements = []; // Global array to store active elements and their positions
    let successScreenAssets = []; // NEW: Global array to store all combined assets (text and image URLs)
    let shuffledSuccessScreenAssets = []; // NEW: Global array for shuffled assets
    let loadingScreen; // NEW: Declare loading screen variable

    // Helper function to shuffle an array
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
      }
      return array;
    }

    // Khai báo các biến DOM element ở phạm vi toàn cục
    let screensaver;
    let bouncingImg;
    let splashScreen;
    let claimButton;
    let audio;
    let body;
    let questionBox;
    let answerInput;
    let submitBtn;
    let errorMessage;
    let attemptsMessage;
    let lockedScreen;
    let errorSound;
    let errorGifOverlay;
    let successScreensaver;
    let fireworksMusic; // Declare new variable for fireworks music
    let mainBackgroundMusic; // Declare new variable for main background music
    let slapsSound; // NEW: Declare slaps sound variable

    const baseGifDuration = 1580; // Thời gian cơ bản cho GIF (miligiây)

    // Helper to check for overlap between two rectangles
    function checkOverlap(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    // Function to find a non-overlapping position
    function findNonOverlappingPosition(elementWidth, elementHeight, maxAttempts = 50) { // Renamed from gifWidth, gifHeight
        let newX, newY;
        let newRect;
        let foundPosition = false;

        for (let i = 0; i < maxAttempts; i++) {
            newX = Math.random() * (window.innerWidth - elementWidth);
            newY = Math.random() * (window.innerHeight - elementHeight);
            newRect = { x: newX, y: newY, width: elementWidth, height: elementHeight };

            let overlaps = false;
            // NEW: Iterate through activeFireworkElements, checking for domElement instead of gifElement
            for (const activeElement of activeFireworkElements) {
                if (activeElement.domElement.isConnected && checkOverlap(newRect, activeElement.rect)) {
                    overlaps = true;
                    break;
                }
            }

            if (!overlaps) {
                foundPosition = true;
                break;
            }
        }

        if (foundPosition) {
            return { x: newX, y: newY };
        } else {
            // If a non-overlapping position cannot be found after maxAttempts,
            // just return a random position and accept potential overlap.
            console.warn('Could not find a non-overlapping position for element after multiple attempts. Placing randomly.');
            return {
                x: Math.random() * (window.innerWidth - elementWidth),
                y: Math.random() * (window.innerHeight - elementHeight)
            };
        }
    }

    function createSnowflake() {
      if (document.querySelectorAll('.snowflake').length > 100) return;
      const snowflake = document.createElement('div');
      snowflake.classList.add('snowflake');
      snowflake.innerHTML = '❄';
      document.body.appendChild(snowflake);
      const startPosition = Math.random() * window.innerWidth;
      const endPosition = window.innerHeight + 20;
      const fallDuration = Math.random() * 5 + 5;
      const startScale = (Math.random() * 0.5 + 0.5) * 1.5;
      const endScale = startScale * 0.3;
      const horizontalDrift = Math.random() * 50 - 25;
      snowflake.style.left = `${startPosition}px`;
      snowflake.style.fontSize = `${startScale}em`;
      snowflake.style.opacity = Math.random() * 0.5 + 0.5;
      const animation = snowflake.animate([
        {
          transform: `translateY(0) translateX(0) scale(${startScale})`,
          opacity: snowflake.style.opacity
        },
        {
          transform: `translateY(${endPosition}px) translateX(${horizontalDrift}px) scale(${endScale})`,
          opacity: 0
        }
      ], {
        duration: fallDuration * 1000,
        easing: 'linear',
        iterations: 1
      });
      animation.onfinish = () => {
        snowflake.remove();
      };
    }

    function startSnowfall(flakeInterval = 133) {
      setInterval(createSnowflake, flakeInterval);
    }

    const songList = [
      "https://github.com/gnid31/meo/raw/main/music/id_072019.mp3",
      "https://github.com/gnid31/meo/raw/main/music/uoc_gi.mp3",
      "https://github.com/gnid31/meo/raw/main/music/hen_mot_mai.mp3",
      "https://github.com/gnid31/meo/raw/main/music/am_tham_ben_em.mp3",
      "https://github.com/gnid31/meo/raw/main/music/neu_ngay_ay.mp3",
      "https://github.com/gnid31/meo/raw/main/music/gia_nhu_em_nhin_lai.mp3",
    ];

    function playSong(index) {
      const songUrl = songList[index];
      showScreensaver(songUrl);
    }

    document.addEventListener('DOMContentLoaded', async () => {
      // Gán các biến DOM element ở đây
      screensaver = document.getElementById("screensaver");
      bouncingImg = document.getElementById("bouncing-image");
      splashScreen = document.getElementById('splash-screen');
      claimButton = document.getElementById('claim-button');
      audio = document.getElementById('myAudio');
      body = document.body;
      questionBox = document.getElementById('question-box');
      answerInput = document.getElementById('secret-answer');
      submitBtn = document.getElementById('submit-answer');
      errorMessage = document.getElementById('error-message');
      attemptsMessage = document.getElementById('attempts-left');
      lockedScreen = document.getElementById('locked-screen');
      errorSound = document.getElementById('error-sound');
      errorGifOverlay = document.getElementById('error-gif-overlay');
      successScreensaver = document.getElementById('success-screensaver'); // Get the new success screensaver
      fireworksMusic = document.getElementById('fireworks-music'); // Get the new fireworks music element
      mainBackgroundMusic = document.getElementById('main-background-music'); // Get the new main background music element
      loadingScreen = document.getElementById('loading-screen'); // NEW: Get the loading screen element
      slapsSound = document.getElementById('slaps-sound'); // NEW: Get the slaps sound element

      // NEW: Get loading screen elements
      let loadingCatGif = document.getElementById('loading-cat-gif');
      let loadingBar = document.querySelector('.loading-bar');
      let loadingPercentageText = document.getElementById('loading-percentage');

      // Logic tải tài nguyên và cập nhật tiến độ
      let totalAssetsToLoad = 0;
      let loadedAssetsCount = 0;

      const updateLoadingProgress = () => {
        loadedAssetsCount++;
        const progress = Math.min(100, Math.floor((loadedAssetsCount / totalAssetsToLoad) * 100)); // Đảm bảo không vượt quá 100%

        if (loadingBar) {
          loadingBar.style.width = `${progress}%`;
        }
        if (loadingPercentageText) {
          loadingPercentageText.textContent = progress;
        }

        // Move GIF based on progress relative to its parent (.loading-bar-container)
        if (loadingCatGif && loadingBar && loadingBar.parentElement) {
          const barContainerWidth = loadingBar.parentElement.offsetWidth;
          // Lấy chiều rộng thực tế của GIF sau khi nó được tải (hoặc dùng giá trị mặc định)
          const gifWidth = loadingCatGif.offsetWidth || 50; 
          
          // Tính toán vị trí mới cho GIF
          const newLeftPx = (progress / 100) * barContainerWidth; 
          // Trừ đi một nửa chiều rộng GIF để nó căn giữa vào điểm tiến độ
          loadingCatGif.style.left = `${newLeftPx - (gifWidth / 2)}px`; 
        }
      };

      function handleAnswerSubmission() {
        const correctAnswer = '107';
        if (answerInput.value.trim() === correctAnswer) {
          questionBox.style.display = 'none';
          // Hide splash screen if it's still visible
          splashScreen.classList.add('hidden');

          // Show success screensaver
          successScreensaver.style.display = 'block';
          // NEW: Allow exit immediately when success screen is shown
          allowExitSuccessScreen = true;
          console.log('allowExitSuccessScreen set to true immediately upon showing success screen.');

          // NEW: Stop main background music when success screen is active
          if (mainBackgroundMusic) {
              mainBackgroundMusic.pause();
              mainBackgroundMusic.currentTime = 0;
              console.log('Main background music stopped.');
          }

          // Kích hoạt pháo hoa và nhạc sau một khoảng thời gian ngắn
          setTimeout(() => {
            startFireworksEffect(); // Bắt đầu hiệu ứng GIF
            if (fireworksMusic) { // Phát nhạc pháo hoa
              console.log('Attempting to load and play fireworks music...');
              fireworksMusic.currentTime = 0; // Ensure it starts from beginning
              fireworksMusic.load(); // Explicitly trigger loading

              fireworksMusic.play().then(() => {
                console.log('Fireworks music started playing successfully.');
                // allowExitSuccessScreen is already true, no need to set here again
              }).catch(error => {
                if (error.name === 'NotAllowedError') {
                  console.error('Autoplay prevented for fireworks music. User interaction needed.');
                  // allowExitSuccessScreen is already true, so no need for a specific fallback timeout here.
                } else if (error.name === 'AbortError') {
                  console.warn('Fireworks music play aborted. This often happens if play() is called, and then pause() or another play() is called rapidly afterwards.');
                } else {
                  console.error('Error playing fireworks music:', error);
                }
              });
            }
            startSnowfall(); // Đã bỏ comment để kích hoạt tuyết rơi
          }, 200); // Initial delay before fireworks and music start

          // Bắt đầu thay đổi ảnh nền khi màn hình pháo hoa kết thúc hoặc bị thoát
        } else {
          attemptsLeft--;
          answerInput.disabled = true;
          submitBtn.disabled = true;

          questionBox.classList.add('shake');

          if (attemptsLeft > 0) {
            // Buộc GIF tải lại từ đầu
            errorGifOverlay.querySelector('#error-gif').src = '';
            errorGifOverlay.querySelector('#error-gif').src = 'https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif';

            errorGifOverlay.classList.add('visible'); // Hiển thị GIF

            const currentGifDuration = baseGifDuration * (3 - attemptsLeft); // Tính toán thời gian dựa trên số lần sai
            setTimeout(() => {
              errorGifOverlay.classList.remove('visible'); // Ẩn GIF sau thời gian tính toán
              answerInput.disabled = false; // Kích hoạt lại ô nhập liệu
              answerInput.focus();          // Tập trung vào ô nhập liệu
              questionBox.classList.remove('shake'); // Remove shake class here
            }, currentGifDuration);
          } else {
            // Nếu là lần cuối cùng (attemptsLeft = 0), không hiển thị GIF,
            // và các nút/ô nhập liệu sẽ không được kích hoạt lại vì hộp câu hỏi sẽ biến mất.
            questionBox.classList.remove('shake'); // Remove shake class here
          }

          if (attemptsLeft <= 0) {
            questionBox.style.display = 'none';
            if (slapsSound) { // NEW: Play slaps sound when attempts run out
                slapsSound.currentTime = 0; // Reset sound to beginning
                slapsSound.play().catch(e => console.error('Error playing slaps sound:', e));
            }
            if (errorSound) { // Ensure error sound is stopped if it was playing
                errorSound.pause();
                errorSound.currentTime = 0;
            }
            if (mainBackgroundMusic) { // NEW: Pause main background music when slaps sound plays
                mainBackgroundMusic.pause();
                mainBackgroundMusic.currentTime = 0;
                console.log('Main background music stopped due to slaps sound.');
            }
            lockedScreen.style.display = 'flex';
          } else {
            errorMessage.textContent = 'Sai rồi, lêu lêu!';
            attemptsMessage.textContent = `Còn ${attemptsLeft} lần nhập thôi nha!`;
            answerInput.value = '';
          }
        }
      }

      if (claimButton && submitBtn && questionBox && answerInput) {
        claimButton.addEventListener('click', () => {
          questionBox.style.display = 'block';
          answerInput.focus();
          // Sau khi hiện question box, đảm bảo nút trả lời đúng trạng thái ban đầu (disabled nếu rỗng)
          if (answerInput.value.trim() === '') {
            submitBtn.disabled = true;
          }
        });

        submitBtn.addEventListener('click', handleAnswerSubmission);

        // Thêm sự kiện 'input' để kiểm tra ô nhập liệu và kích hoạt/vô hiệu hóa nút
        answerInput.addEventListener('input', () => {
          if (answerInput.value.trim() === '') {
            submitBtn.disabled = true; // Đảm bảo nút bị vô hiệu hóa khi input rỗng
          } else {
            submitBtn.disabled = false;
          }
        });


        answerInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            // Chỉ gọi handleAnswerSubmission nếu nút không bị disabled (tức là input không rỗng)
            if (!submitBtn.disabled) {
              handleAnswerSubmission();
            }
          }
        });


        window.addEventListener('keydown', (e) => {
          // Chỉ xử lý F5 để reset khi màn hình bị khóa đang hiển thị
          if (e.key === 'F5' && lockedScreen.style.display === 'flex') {
            e.preventDefault(); // Ngăn trang reload

            attemptsLeft = 3;
            errorMessage.textContent = '';
            attemptsMessage.textContent = '';
            answerInput.value = ''; // Xóa giá trị
            lockedScreen.style.display = 'none';
            questionBox.style.display = 'block';
            answerInput.disabled = false; // Kích hoạt lại ô nhập liệu
            answerInput.focus();
            // Kích hoạt lại nút trả lời sẽ được xử lý tự động khi value của input thay đổi (thành rỗng)
            answerInput.dispatchEvent(new Event('input')); // Kích hoạt sự kiện input để cập nhật trạng thái nút

            // Đảm bảo dừng và xóa pháo hoa khi reset hoàn toàn
            if (fireworkInterval) {
              clearInterval(fireworkInterval);
              fireworkInterval = null;
            }
            if (successScreensaver) {
              successScreensaver.style.display = 'none';
              if (fireworksMusic) { // Stop fireworks music
                fireworksMusic.pause();
                fireworksMusic.currentTime = 0;
              }
              allowExitSuccessScreen = false; // Đặt lại cờ
              activeFireworkElements = []; // Clear all active fireworks
            }
            // NEW: Stop slaps sound if playing when F5 is pressed on locked screen
            if (slapsSound && lockedScreen.style.display === 'flex') {
                slapsSound.pause();
                slapsSound.currentTime = 0;
                console.log('Slaps sound stopped due to F5 press.');
            }
          } else if (successScreensaver && successScreensaver.style.display === 'block' && allowExitSuccessScreen) { // Thêm điều kiện cờ
            successScreensaver.style.display = 'none';
            if (fireworkInterval) {
              clearInterval(fireworkInterval);
              fireworkInterval = null;
            }
            if (fireworksMusic) { // Stop fireworks music
              fireworksMusic.pause();
              fireworksMusic.currentTime = 0;
            }
            if (mainBackgroundMusic) { // Stop main background music
              mainBackgroundMusic.pause();
              mainBackgroundMusic.currentTime = 0;
            }
            // NEW: Play main background music when success screensaver is exited
            if (mainBackgroundMusic) {
                console.log('Attempting to load and play main background music upon success screen exit...');
                mainBackgroundMusic.load();
                mainBackgroundMusic.play().then(() => {
                    console.log('Main background music started playing successfully after success screen exit.');
                }).catch(error => {
                    console.error('Error playing main background music on success screen exit:', error);
                });
            }
          }
        });


      } else {
        console.error('Một hoặc nhiều phần tử không được tìm thấy trong DOM.');
      }

      // Show loading screen immediately
      if (loadingScreen) {
        loadingScreen.classList.remove('hidden');
      }

      // Pre-calculate total assets by fetching asset lists
      // We don't await these fully, just get their initial data
      const [listText, wallpaperText, assetsText] = await Promise.all([
          fetch('https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/list.txt').then(res => res.text()).catch(() => ''),
          fetch('https://raw.githubusercontent.com/gnid31/meo/main/wallpaper.txt').then(res => res.text()).catch(() => ''),
          fetch('https://raw.githubusercontent.com/gnid31/meo/main/assets.txt').then(res => res.text()).catch(() => '')
      ]);

      totalAssetsToLoad += listText.split('\n').filter(url => url.trim() !== '').length;
      totalAssetsToLoad += wallpaperText.split('\n').filter(url => url.trim() !== '').length;
      totalAssetsToLoad += assetsText.split('\n').map(asset => asset.trim()).filter(asset => asset !== '').length;

      // Handle case where totalAssetsToLoad might be 0 (e.g., if files are empty or fail to load)
      if (totalAssetsToLoad === 0) {
          totalAssetsToLoad = 1; // Prevent division by zero, ensure 100% can be reached
      }

      // Collect all individual asset promises
      const allAssetPromises = [
        ...(await loadImages(updateLoadingProgress)),
        ...(await loadWallpaperImages(updateLoadingProgress)),
        ...(await loadSuccessScreenAssets(updateLoadingProgress))
      ];

      // Wait for all individual assets to load
      await Promise.allSettled(allAssetPromises);

      console.log('All assets loaded. Hiding loading screen.');
      // Ensure progress is 100% just before hiding
      if (loadingBar) {
          loadingBar.style.width = '100%';
      }
      if (loadingPercentageText) {
          loadingPercentageText.textContent = '100';
      }
      if (loadingCatGif) {
          const barContainerWidth = loadingBar.parentElement.offsetWidth;
          const gifWidth = loadingCatGif.offsetWidth || 50;
          loadingCatGif.style.left = `${barContainerWidth - (gifWidth / 2)}px`; // Move to the very end
      }
      
      // Add a small delay before hiding for a smoother visual transition to 100%
      setTimeout(() => {
        if (loadingScreen) {
          loadingScreen.classList.add('hidden');
        }
        // NEW: Play main background music automatically after loading is complete
        if (mainBackgroundMusic) {
            console.log('Attempting to load and play main background music after loading screen is hidden...');
            mainBackgroundMusic.load(); // Ensure it's loaded
            mainBackgroundMusic.play().then(() => {
                console.log('Main background music started playing successfully after loading.');
            }).catch(error => {
                console.error('Error playing main background music after loading:', error);
            });
        }
      }, 300); // 300ms delay

      console.log('Hoàn thành tải ảnh');
      // Ban đầu vô hiệu hóa nút submit nếu input rỗng
      if (answerInput.value.trim() === '') {
        submitBtn.disabled = true;
      }

      // Start background change only after wallpapers are loaded
      startBackgroundChange();
    });


    const bouncingImages = [];

    // Hàm để đọc danh sách ảnh từ URL và tải trước chúng
    async function loadImages(progressCallback) {
      console.log('Bắt đầu tải danh sách ảnh...');
      try {
        const response = await fetch('https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/list.txt');
        const text = await response.text();
        const imageUrls = text.split('\n').filter(url => url.trim() !== '');

        const promises = imageUrls.map(url => {
          return new Promise(resolve => {
            const img = new Image();
            img.src = url;
            img.onload = () => {
              bouncingImages.push(img);
              if (progressCallback) progressCallback();
              resolve();
            };
            img.onerror = () => {
              console.error(`Failed to load bouncing image: ${url}`);
              if (progressCallback) progressCallback();
              resolve();
            };
          });
        });
        console.log('Đã tạo Promises cho ảnh bouncing. Số lượng:', promises.length);
        return promises;
      } catch (error) {
        console.error('Error loading bouncing image list:', error);
        return [];
      }
    }

    // New function for fireworks effect
    function startFireworksEffect() {
      if (fireworkInterval) {
        clearInterval(fireworkInterval); // Clear any existing interval
      }

      fireworkInterval = setInterval(() => {
        // NEW: Check if shuffled array is empty, if so, reshuffle
        if (shuffledSuccessScreenAssets.length === 0) {
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
            console.log('Shuffled success screen assets reloaded and reshuffled.');
        }

        // NEW: Get the next asset from the shuffled array
        if (shuffledSuccessScreenAssets.length === 0) {
            console.warn('No success screen assets available after reshuffling.');
            return; // Exit if no assets are available even after reshuffling (should not happen if successScreenAssets is populated)
        }
        const randomAsset = shuffledSuccessScreenAssets.shift(); // Get and remove the first element

        let newElement;
        let estimatedWidth, estimatedHeight;

        // NEW: Determine if the asset is an image or text
        const isImage = /\.(gif|jpe?g|png|webp)$/i.test(randomAsset);

        if (isImage) {
            newElement = document.createElement('img');
            newElement.classList.add('firework-gif'); // Reuse firework-gif class for styling images
            newElement.src = randomAsset;
            estimatedWidth = 150; // Use estimated GIF dimensions
            estimatedHeight = 150;
        } else {
            newElement = document.createElement('div');
            newElement.classList.add('success-bouncing-text'); // Use specific class for text
            newElement.textContent = randomAsset;
            estimatedWidth = 300; // Use estimated text dimensions
            estimatedHeight = 70;
        }

        // Find a non-overlapping position
        const position = findNonOverlappingPosition(estimatedWidth, estimatedHeight);

        newElement.style.left = `${position.x}px`;
        newElement.style.top = `${position.y}px`;

        successScreensaver.appendChild(newElement);

        // Add to active list
        const assetEntry = {
            domElement: newElement, // Store the created DOM element
            rect: { x: position.x, y: position.y, width: estimatedWidth, height: estimatedHeight }
        };
        activeFireworkElements.push(assetEntry);

        // Update exact dimensions once rendered for more accurate overlap checking
        // Use an event listener for images to get actual dimensions once loaded
        if (isImage) {
            newElement.onload = () => {
                assetEntry.rect.width = newElement.offsetWidth;
                assetEntry.rect.height = newElement.offsetHeight;
            };
        } else {
            // For text, offsetWidth/Height are usually available immediately after append
            setTimeout(() => {
                assetEntry.rect.width = newElement.offsetWidth;
                assetEntry.rect.height = newElement.offsetHeight;
            }, 0);
        }


        // Remove element and its position entry after its animation duration
        const animationDurationMs = 6 * 1000; // Match CSS animation duration (6s)
        setTimeout(() => {
            newElement.remove();
            // Remove from activeFireworkElements array
            const index = activeFireworkElements.indexOf(assetEntry);
            if (index > -1) {
                activeFireworkElements.splice(index, 1);
            }
        }, animationDurationMs);

      }, 600); // Create asset every 600ms
    }

    // New function to clear all fireworks assets
    function clearFireworks() {
      if (successScreensaver) {
        // NEW: Select and remove both text and image elements with their respective classes
        while (successScreensaver.querySelector('.success-bouncing-text')) {
          successScreensaver.querySelector('.success-bouncing-text').remove();
        }
        while (successScreensaver.querySelector('.firework-gif')) {
          successScreensaver.querySelector('.firework-gif').remove();
        }
      }
    }


    // Function to change background image
    function changeBackgroundImage() {
        if (wallpaperImageUrls.length === 0) {
            console.warn('No wallpaper images loaded.');
            return;
        }
        currentBackgroundIndex = (currentBackgroundIndex + 1) % wallpaperImageUrls.length;
        body.style.backgroundImage = `url(${wallpaperImageUrls[currentBackgroundIndex]})`;
    }

    // Function to start automatic background change
    function startBackgroundChange() {
        if (backgroundChangeInterval) {
            clearInterval(backgroundChangeInterval);
        }
        // Thay đổi ảnh nền ngay lập tức lần đầu
        changeBackgroundImage();
        // Sau đó thay đổi ảnh nền mỗi 5 giây (hoặc thời gian bạn muốn)
        backgroundChangeInterval = setInterval(changeBackgroundImage, 5000); // Change every 5 seconds
    }

    // New function to load wallpaper images from example.txt
    async function loadWallpaperImages(progressCallback) {
        try {
            console.log('Attempting to load wallpaper image URLs from wallpaper.txt...');
            const timestamp = new Date().getTime(); // Cache busting
            const response = await fetch(`https://raw.githubusercontent.com/gnid31/meo/main/wallpaper.txt?t=${timestamp}`);
            if (!response.ok) {
                console.error(`Failed to fetch wallpaper.txt: HTTP error! status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            const urls = text.split('\n').filter(url => url.trim() !== '');
            
            const promises = urls.map(url => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.src = url;
                    img.onload = () => {
                        wallpaperImageUrls.push(url); // Chỉ thêm URL vào mảng chính
                        if (progressCallback) progressCallback();
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to preload wallpaper image: ${url}`);
                        if (progressCallback) progressCallback();
                        resolve();
                    };
                });
            });
            console.log('Đã tạo Promises cho ảnh nền. Số lượng:', promises.length);
            return promises;
        } catch (error) {
            console.error('Error loading wallpaper images from wallpaper.txt:', error);
            // Fallback to a default image or show an error
            body.style.backgroundImage = `url("C:/Users/ADMIN/Desktop/meomeo/wallpaper/e82e59a091fccfe88d581ef7dc56f070.jpg")`; // Fallback to a default if loading fails
            return [];
        }
    }

    // NEW: Function to load all assets for the success screen from a single file
    async function loadSuccessScreenAssets(progressCallback) {
        try {
            console.log('Attempting to load success screen assets from assets.txt...');
            const timestamp = new Date().getTime(); // Cache busting
            const response = await fetch(`https://raw.githubusercontent.com/gnid31/meo/main/assets.txt?t=${timestamp}`);
            if (!response.ok) {
                console.error(`Failed to fetch assets.txt: HTTP error! status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            const assets = text.split('\n').map(asset => asset.trim()).filter(asset => asset !== '');
            
            const promises = assets.map(asset => {
                return new Promise(resolve => {
                    // Kiểm tra nếu là ảnh để tải trước
                    const isImage = /\.(gif|jpe?g|png|webp)$/i.test(asset);
                    if (isImage) {
                        const img = new Image();
                        img.src = asset;
                        img.onload = () => {
                            successScreenAssets.push(asset); // Thêm vào mảng chính
                            if (progressCallback) progressCallback();
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn(`Failed to preload success screen asset image: ${asset}`);
                            successScreenAssets.push(asset); // Vẫn thêm vào để đảm bảo xuất hiện
                            if (progressCallback) progressCallback();
                            resolve();
                        };
                    } else {
                        successScreenAssets.push(asset); // Thêm văn bản trực tiếp
                        if (progressCallback) progressCallback();
                        resolve();
                    }
                });
            });
            // Initialize and shuffle the shuffled array after all assets are collected
            await Promise.allSettled(promises); // Đảm bảo tất cả asset đã được xử lý (kể cả tải trước ảnh)
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
            console.log('Successfully loaded and shuffled success screen assets. Count:', successScreenAssets.length);
            console.log('Loaded assets:', successScreenAssets);
            return promises;
        } catch (error) {
            console.error('Error loading success screen assets from assets.txt:', error);
            // Fallback to default assets if loading fails
            successScreenAssets = ["Chúc mừng!", "https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif"];
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
            return [];
        }
    }

  </script>
  <div id="screensaver">
    <div id="exit-hint">Press any key to exit (trừ nút Space)</div>
    <img id="bouncing-image" src="" alt="Bouncing" />
  </div>



</body>

</html>