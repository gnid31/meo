<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>by gnid31</title>
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif">
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif">
  <link rel="preload" as="image" href="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/fight3.gif">
  <link rel="preload" as="audio" href="https://github.com/gnid31/meo/raw/main/music/happy_birthday.mp3">
  <link rel="preload" as="audio" href="https://github.com/gnid31/meo/raw/main/music/background_music.mp3">
  <link rel="preload" as="fetch" type="text/plain" href="https://raw.githubusercontent.com/gnid31/meo/main/assets.txt">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #FFC0CB;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      color: #333;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 20px;
      box-sizing: border-box;
      overflow: hidden;
      transition: background-image 1s ease-in-out;
    }

    .container {
      background-color: rgba(255, 255, 255, 0.7);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 500px;
      width: 100%;
      position: relative;
      z-index: 10;
    }

    h1 {
      color: #FF69B4;
      margin-top: 0;
      margin-bottom: 25px;
      font-size: 2.5em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      animation: wave 2s ease-in-out infinite alternate;
    }

    audio {
      display: none;
    }

    p {
      font-size: 1.2em;
      line-height: 1.7;
      color: #FF1493;
      margin-top: 20px;
      font-style: italic;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    }

    .snowflake {
      color: #fff;
      font-size: 1.2em;
      position: fixed;
      top: -10px;
      opacity: 0.7;
      user-select: none;
      pointer-events: none;
    }

    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #FFC0CB;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
      text-align: center;
      transition: opacity 0.5s ease-out;
    }

    #splash-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #mystery-text {
      font-size: 3.5em;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
      margin-bottom: 30px;
      animation: bounce 1s infinite alternate;
    }

    @keyframes bounce {
      0% {
        transform: translateY(0);
      }

      100% {
        transform: translateY(-10px);
      }
    }

    #exit-hint {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 1px 1px 3px black;
      z-index: 100001;
      animation: gentleShake 2s infinite ease-in-out;
    }


    #gift-box {
      width: 150px;
      height: 150px;
      margin-bottom: 40px;
      position: relative;
    }

    #claim-button {
      background-color: #FF1493;
      color: white;
      border: none;
      padding: 15px 40px;
      border-radius: 10px;
      font-size: 2em;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, scale 0.2s ease-in-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    #claim-button:hover {
      background-color: #e60073;
      transform: translateY(-2px);
      scale: 1.05;
    }

    #question-box {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      border: 3px solid #FF69B4;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      z-index: 10000;
      transform-origin: center;
    }

    #error-message {
      color: red;
      margin-top: 10px;
      font-weight: bold;
    }

    #attempts-left {
      color: red;
      margin-top: 5px;
    }

    #locked-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10001;
      color: #fff;
      font-size: 2em;
      text-align: center;
      padding: 20px;
      transition: opacity 0.3s ease-in-out;
    }

    #locked-screen .highlight-text {
      font-size: 3em;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 0 0 15px #ff69b4, 0 0 25px #ff1493, 2px 2px 10px rgba(0, 0, 0, 0.7);
      animation: glowText 1.5s ease-in-out infinite alternate;
    }

    #song-buttons {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    #song-buttons button {
      background-color: #FF69B4;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 5px 8px;
      margin: 0;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s ease;
      width: auto;
    }

    #song-buttons button:hover {
      background-color: #e60073;
      transform: scale(1.05);
    }


    @keyframes glowText {
      from {
        text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493;
        transform: scale(1);
      }

      to {
        text-shadow: 0 0 20px #ff69b4, 0 0 30px #ff1493;
        transform: scale(1.05);
      }
    }

    @keyframes gentleShake {
      0% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-2px);
      }

      50% {
        transform: translateX(2px);
      }

      75% {
        transform: translateX(-1px);
      }

      100% {
        transform: translateX(0);
      }
    }

    #locked-screen .f5-hint {
      animation: gentleShake 1s infinite ease-in-out;
      font-size: 0.8em;
      margin-top: 20px;
      color: #fff;
      opacity: 0.9;
    }

    #screensaver {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      z-index: 100000;
      display: none;
      overflow: hidden;
    }

    #screensaver img {
      position: absolute;
      width: 200px;
      height: 200px;
      object-fit: contain;
      pointer-events: none;
    }


    @media (max-width: 600px) {
      .container {
        padding: 25px 30px;
      }

      h1 {
        font-size: 2em;
      }

      p {
        font-size: 1.1em;
      }

      #mystery-text {
        font-size: 2.5em;
      }

      #gift-box {
        width: 120px;
        height: 120px;
      }

      #claim-button {
        font-size: 1.5em;
        padding: 12px 30px;
      }
    }

    @keyframes shake {

      0%,
      100% {
        transform: translate(-50%, -50%);
      }

      10%,
      30%,
      50%,
      70%,
      90% {
        transform: translate(calc(-50% - 5px), calc(-50% - 2px));
      }

      20%,
      40%,
      60%,
      80% {
        transform: translate(calc(-50% + 5px), calc(-50% + 2px));
      }
    }

    .shake {
      animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }

    .popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 10002;
      justify-content: center;
      align-items: center;
    }

    .popup-content {
      background-color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: popupAppear 0.5s ease-out;
      border: 3px solid #FF69B4;
      box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
    }

    .popup-content h2 {
      color: #FF1493;
      margin-bottom: 20px;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    #close-popup {
      background-color: #FF69B4;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.3s ease;
    }

    #close-popup:hover {
      background-color: #FF1493;
      transform: scale(1.05);
    }

    @keyframes popupAppear {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* New CSS for the GIF overlay */
    #error-gif-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent; /* ƒê√£ thay ƒë·ªïi t·ª´ rgb(255, 255, 255) th√†nh transparent */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10003; /* Above question box */
      pointer-events: none; /* Allow clicks to pass through if needed */
      opacity: 0; /* Initially hidden */
      transition: opacity 0.3s ease-in-out;
    }

    #error-gif-overlay.visible {
      opacity: 1;
    }

    #error-gif {
      width: 700px; /* Adjust size as needed */
      height: 700px; /* Adjust size as needed */
      object-fit: contain; /* Ensure the GIF maintains its aspect ratio while fitting */
      transform: translateY(-100px); /* Move the GIF up by 100px */
    }

    /* New styles for submit-answer button */
    #submit-answer {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #FF69B4;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s ease, background-color 0.3s ease; /* Th√™m hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªïi m∆∞·ª£t m√† */
    }

    #submit-answer:hover:not(:disabled) {
      background-color: #e60073; /* M√†u t·ªëi h∆°n khi hover */
      transform: scale(1.05); /* Ph·ªìng ra m·ªôt ch√∫t */
    }

    #submit-answer:disabled {
      background-color: #cccccc; /* M√†u x√°m khi b·ªã v√¥ hi·ªáu h√≥a */
      cursor: not-allowed;
    }

    /* New CSS for success screensaver */
    #success-screensaver {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #FFC0CB; /* M√†u h·ªìng ph·∫•n */
      display: none; /* Hidden by default */
      overflow: hidden;
      z-index: 9999;
    }

    #success-screensaver .firework-gif {
      position: absolute;
      width: 150px; /* K√≠ch th∆∞·ªõc c∆° b·∫£n c·ªßa GIF ph√°o hoa */
      height: auto;
      opacity: 0;
      animation: fadeAndMove 6s ease-out forwards; /* Ho·∫°t ·∫£nh fade out v√† di chuy·ªÉn */
      pointer-events: none;
    }

    /* NEW CSS for bouncing text on success screensaver */
    #success-screensaver .success-bouncing-text {
      position: absolute;
      font-size: 3em; /* Larger font size for impact */
      font-weight: bold;
      color: white; /* Changed to white for brighter effect */
      text-shadow: 0 0 15px #FF1493, 0 0 25px #FF69B4, 0 0 40px #FFD700; /* Increased shadows for more glow */
      opacity: 0;
      animation: fadeAndMove 6s ease-out forwards; /* Reuse existing animation */
      pointer-events: none;
      white-space: nowrap; /* Prevent text from wrapping */
    }

    /* New styles for success exit hint */
    #success-exit-hint {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 3px black;
      z-index: 100001;
      animation: gentleShake 2s infinite ease-in-out; /* √Åp d·ª•ng animation gentleShake */
    }

    @keyframes fadeAndMove {
      0% {
        opacity: 0;
        transform: translateY(0) scale(0.5);
      }
      20% {
        opacity: 1;
        transform: translateY(-20px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) scale(0.8);
      }
    }
  </style>
</head>

<body>
  <div id="splash-screen">
    <div id="mystery-text">Mystery Box</div>
    <img id="gift-box"
      src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif"
      alt="Gift Box">
    <button id="claim-button">Unbox</button>
  </div>

  <div id="question-box">
    <div><strong>C√¢u h·ªèi b√≠ m·∫≠t:</strong> Chu·ªói ƒë·ªïi m√†u l√∫c bao nhiu t·ªßi???</div>
    <input type="text" id="secret-answer" placeholder="Nh·∫≠p c√¢u tr·∫£ l·ªùi..."
      style="padding: 10px; font-size: 1em; margin-top: 15px; width: 80%;">
    <button id="submit-answer">Tr·∫£ l·ªùi</button>
    <div id="error-message"></div>
    <div id="attempts-left"></div>
    <!-- New GIF overlay -->
    <div id="error-gif-overlay">
      <img id="error-gif" src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif" alt="Error GIF">
    </div>
  </div>

  <div id="locked-screen">
    <div class="highlight-text">
      <div>ƒë√°ng ƒë√°nh!!!</div>
    </div>
    <!-- New GIF for locked screen -->
    <img id="fight-gif" src="https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/fight3.gif" alt="Fight GIF" style="width: 500px; height: auto; margin-top: 30px;">
    <div class="f5-hint">Press F5 to continue opening the Mystery Box</div>
  </div>

  <div class="container">
    <h1>M√®o m√©o meo m√®o me0o0o0!</h1>
    <div id="song-selector">
      <p>üéµ √Çm nh·∫°c l√† music</p>
      <div id="song-buttons">
        <button onclick="playSong(0)">meo 8</button>
        <button onclick="playSong(1)">meo 20</button>
        <button onclick="playSong(2)">meo 7</button>
        <button onclick="playSong(3)">meo 0</button>
        <button onclick="playSong(4)">meo 13</button>
        <button onclick="playSong(5)">meo 6</button>
      </div>
    </div>

    <audio id="myAudio" controls>
      <source id="audio-source" src="" type="audio/mpeg">
      Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ audio.
    </audio>

    <p></p>
  </div>

  <audio id="error-sound" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>

  <!-- New audio for fireworks background music -->
  <audio id="fireworks-music" src="https://github.com/gnid31/meo/raw/main/music/happy_birthday.mp3" loop></audio>

  <!-- New audio for main background music -->
  <audio id="main-background-music" src="https://github.com/gnid31/meo/raw/main/music/background_music.mp3" loop></audio>

  <!-- New success screensaver HTML -->
  <div id="success-screensaver">
    <div id="success-exit-hint">Press any key to exit</div>
  </div>

  <script>
    console.log("Script loaded and starting execution.");

    // const BACKGROUND_IMAGE_URL = "C:/Users/ADMIN/Desktop/meomeo/wallpaper/e82e59a091fccfe88d581ef7dc56f070.jpg";
    let wallpaperImageUrls = []; // New global array for wallpaper image URLs
    let currentBackgroundIndex = 0;
    let backgroundChangeInterval = null; // Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ interval thay ƒë·ªïi ·∫£nh n·ªÅn
    let attemptsLeft = 4;
    let fireworkInterval = null;
    let animationInterval = null; // C·∫ßn l√† global ƒë·ªÉ showScreensaver c√≥ th·ªÉ clear n√≥
    let allowExitSuccessScreen = false; // Khai b√°o bi·∫øn c·ªù m·ªõi
    let activeFireworkElements = []; // Global array to store active elements and their positions
    let successScreenAssets = []; // NEW: Global array to store all combined assets (text and image URLs)
    let shuffledSuccessScreenAssets = []; // NEW: Global array for shuffled assets

    // Helper function to shuffle an array
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
      }
      return array;
    }

    // Khai b√°o c√°c bi·∫øn DOM element ·ªü ph·∫°m vi to√†n c·ª•c
    let screensaver;
    let bouncingImg;
    let splashScreen;
    let claimButton;
    let audio;
    let body;
    let questionBox;
    let answerInput;
    let submitBtn;
    let errorMessage;
    let attemptsMessage;
    let lockedScreen;
    let errorSound;
    let errorGifOverlay;
    let successScreensaver;
    let fireworksMusic; // Declare new variable for fireworks music
    let mainBackgroundMusic; // Declare new variable for main background music

    const baseGifDuration = 1580; // Th·ªùi gian c∆° b·∫£n cho GIF (miligi√¢y)

    // Helper to check for overlap between two rectangles
    function checkOverlap(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    // Function to find a non-overlapping position
    function findNonOverlappingPosition(elementWidth, elementHeight, maxAttempts = 50) { // Renamed from gifWidth, gifHeight
        let newX, newY;
        let newRect;
        let foundPosition = false;

        for (let i = 0; i < maxAttempts; i++) {
            newX = Math.random() * (window.innerWidth - elementWidth);
            newY = Math.random() * (window.innerHeight - elementHeight);
            newRect = { x: newX, y: newY, width: elementWidth, height: elementHeight };

            let overlaps = false;
            // NEW: Iterate through activeFireworkElements, checking for domElement instead of gifElement
            for (const activeElement of activeFireworkElements) {
                if (activeElement.domElement.isConnected && checkOverlap(newRect, activeElement.rect)) {
                    overlaps = true;
                    break;
                }
            }

            if (!overlaps) {
                foundPosition = true;
                break;
            }
        }

        if (foundPosition) {
            return { x: newX, y: newY };
        } else {
            // If a non-overlapping position cannot be found after maxAttempts,
            // just return a random position and accept potential overlap.
            console.warn('Could not find a non-overlapping position for element after multiple attempts. Placing randomly.');
            return {
                x: Math.random() * (window.innerWidth - elementWidth),
                y: Math.random() * (window.innerHeight - elementHeight)
            };
        }
    }

    function createSnowflake() {
      if (document.querySelectorAll('.snowflake').length > 100) return;
      const snowflake = document.createElement('div');
      snowflake.classList.add('snowflake');
      snowflake.innerHTML = '‚ùÑ';
      document.body.appendChild(snowflake);
      const startPosition = Math.random() * window.innerWidth;
      const endPosition = window.innerHeight + 20;
      const fallDuration = Math.random() * 5 + 5;
      const startScale = (Math.random() * 0.5 + 0.5) * 1.5;
      const endScale = startScale * 0.3;
      const horizontalDrift = Math.random() * 50 - 25;
      snowflake.style.left = `${startPosition}px`;
      snowflake.style.fontSize = `${startScale}em`;
      snowflake.style.opacity = Math.random() * 0.5 + 0.5;
      const animation = snowflake.animate([
        {
          transform: `translateY(0) translateX(0) scale(${startScale})`,
          opacity: snowflake.style.opacity
        },
        {
          transform: `translateY(${endPosition}px) translateX(${horizontalDrift}px) scale(${endScale})`,
          opacity: 0
        }
      ], {
        duration: fallDuration * 1000,
        easing: 'linear',
        iterations: 1
      });
      animation.onfinish = () => {
        snowflake.remove();
      };
    }

    function startSnowfall(flakeInterval = 133) {
      setInterval(createSnowflake, flakeInterval);
    }

    const songList = [
      "https://github.com/gnid31/meo/raw/main/music/id_072019.mp3",
      "https://github.com/gnid31/meo/raw/main/music/uoc_gi.mp3",
      "https://github.com/gnid31/meo/raw/main/music/hen_mot_mai.mp3",
      "https://github.com/gnid31/meo/raw/main/music/am_tham_ben_em.mp3",
      "https://github.com/gnid31/meo/raw/main/music/neu_ngay_ay.mp3",
      "https://github.com/gnid31/meo/raw/main/music/gia_nhu_em_nhin_lai.mp3",
    ];

    function playSong(index) {
      const songUrl = songList[index];
      showScreensaver(songUrl);
    }

    document.addEventListener('DOMContentLoaded', async () => {

      // G√°n c√°c bi·∫øn DOM element ·ªü ƒë√¢y
      screensaver = document.getElementById("screensaver");
      bouncingImg = document.getElementById("bouncing-image");
      splashScreen = document.getElementById('splash-screen');
      claimButton = document.getElementById('claim-button');
      audio = document.getElementById('myAudio');
      body = document.body;
      questionBox = document.getElementById('question-box');
      answerInput = document.getElementById('secret-answer');
      submitBtn = document.getElementById('submit-answer');
      errorMessage = document.getElementById('error-message');
      attemptsMessage = document.getElementById('attempts-left');
      lockedScreen = document.getElementById('locked-screen');
      errorSound = document.getElementById('error-sound');
      errorGifOverlay = document.getElementById('error-gif-overlay');
      successScreensaver = document.getElementById('success-screensaver'); // Get the new success screensaver
      fireworksMusic = document.getElementById('fireworks-music'); // Get the new fireworks music element
      mainBackgroundMusic = document.getElementById('main-background-music'); // Get the new main background music element

      // NEW: Attempt to play background music on first user interaction to satisfy autoplay policy
      let hasInteracted = false;
      const enableAutoplay = () => {
        if (!hasInteracted && mainBackgroundMusic) {
          mainBackgroundMusic.play().then(() => {
            console.log('Main background music started playing due to user interaction.');
            hasInteracted = true;
            document.removeEventListener('click', enableAutoplay);
            document.removeEventListener('keydown', enableAutoplay);
          }).catch(error => {
            if (error.name === 'NotAllowedError') {
              console.warn('Autoplay prevented for main background music. User interaction needed again.');
            } else if (error.name === 'AbortError') {
              console.warn('Main background music play aborted.');
            } else {
              console.error('Error playing main background music:', error);
            }
          });
        }
      };
      document.addEventListener('click', enableAutoplay);
      document.addEventListener('keydown', enableAutoplay);

      function handleAnswerSubmission() {
        const correctAnswer = '107';
        if (answerInput.value.trim() === correctAnswer) {
          questionBox.style.display = 'none';
          // Hide splash screen if it's still visible
          splashScreen.classList.add('hidden');

          // Show success screensaver
          successScreensaver.style.display = 'block';
          // NEW: Allow exit immediately when success screen is shown
          allowExitSuccessScreen = true;
          console.log('allowExitSuccessScreen set to true immediately upon showing success screen.');

          // NEW: Stop main background music when success screen is active
          if (mainBackgroundMusic) {
              mainBackgroundMusic.pause();
              mainBackgroundMusic.currentTime = 0;
              console.log('Main background music stopped.');
          }

          // K√≠ch ho·∫°t ph√°o hoa v√† nh·∫°c sau m·ªôt kho·∫£ng th·ªùi gian ng·∫Øn
          setTimeout(() => {
            startFireworksEffect(); // B·∫Øt ƒë·∫ßu hi·ªáu ·ª©ng GIF
            if (fireworksMusic) { // Ph√°t nh·∫°c ph√°o hoa
              console.log('Attempting to load and play fireworks music...');
              fireworksMusic.currentTime = 0; // Ensure it starts from beginning
              fireworksMusic.load(); // Explicitly trigger loading

              fireworksMusic.play().then(() => {
                console.log('Fireworks music started playing successfully.');
                // allowExitSuccessScreen is already true, no need to set here again
              }).catch(error => {
                if (error.name === 'NotAllowedError') {
                  console.error('Autoplay prevented for fireworks music. User interaction needed.');
                  // allowExitSuccessScreen is already true, so no need for a specific fallback timeout here.
                } else if (error.name === 'AbortError') {
                  console.warn('Fireworks music play aborted. This often happens if play() is called, and then pause() or another play() is called rapidly afterwards.');
                } else {
                  console.error('Error playing fireworks music:', error);
                }
              });
            }
            startSnowfall(); // ƒê√£ b·ªè comment ƒë·ªÉ k√≠ch ho·∫°t tuy·∫øt r∆°i
          }, 200); // Initial delay before fireworks and music start

          // B·∫Øt ƒë·∫ßu thay ƒë·ªïi ·∫£nh n·ªÅn khi m√†n h√¨nh ph√°o hoa k·∫øt th√∫c ho·∫∑c b·ªã tho√°t
        } else {
          attemptsLeft--;
          answerInput.disabled = true;
          submitBtn.disabled = true;

          questionBox.classList.add('shake');

          if (attemptsLeft > 0) {
            // Bu·ªôc GIF t·∫£i l·∫°i t·ª´ ƒë·∫ßu
            errorGifOverlay.querySelector('#error-gif').src = '';
            errorGifOverlay.querySelector('#error-gif').src = 'https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/bite.gif';

            errorGifOverlay.classList.add('visible'); // Hi·ªÉn th·ªã GIF

            const currentGifDuration = baseGifDuration * (4 - attemptsLeft); // T√≠nh to√°n th·ªùi gian d·ª±a tr√™n s·ªë l·∫ßn sai
            setTimeout(() => {
              errorGifOverlay.classList.remove('visible'); // ·∫®n GIF sau th·ªùi gian t√≠nh to√°n
              answerInput.disabled = false; // K√≠ch ho·∫°t l·∫°i √¥ nh·∫≠p li·ªáu
              answerInput.focus();          // T·∫≠p trung v√†o √¥ nh·∫≠p li·ªáu
              questionBox.classList.remove('shake'); // Remove shake class here
            }, currentGifDuration);
          } else {
            // N·∫øu l√† l·∫ßn cu·ªëi c√πng (attemptsLeft = 0), kh√¥ng hi·ªÉn th·ªã GIF,
            // v√† c√°c n√∫t/√¥ nh·∫≠p li·ªáu s·∫Ω kh√¥ng ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i v√¨ h·ªôp c√¢u h·ªèi s·∫Ω bi·∫øn m·∫•t.
            questionBox.classList.remove('shake'); // Remove shake class here
          }

          if (attemptsLeft <= 0) {
            questionBox.style.display = 'none';
            lockedScreen.style.display = 'flex';
          } else {
            errorMessage.textContent = 'Sai r·ªìi, l√™u l√™u!';
            attemptsMessage.textContent = `C√≤n ${attemptsLeft} l·∫ßn nh·∫≠p th√¥i nha!`;
            answerInput.value = '';
          }
        }
      }

      if (claimButton && submitBtn && questionBox && answerInput) {
        claimButton.addEventListener('click', () => {
          questionBox.style.display = 'block';
          answerInput.focus();
          // Sau khi hi·ªán question box, ƒë·∫£m b·∫£o n√∫t tr·∫£ l·ªùi ƒë√∫ng tr·∫°ng th√°i ban ƒë·∫ßu (disabled n·∫øu r·ªóng)
          if (answerInput.value.trim() === '') {
            submitBtn.disabled = true;
          }
        });

        submitBtn.addEventListener('click', handleAnswerSubmission);

        // Th√™m s·ª± ki·ªán 'input' ƒë·ªÉ ki·ªÉm tra √¥ nh·∫≠p li·ªáu v√† k√≠ch ho·∫°t/v√¥ hi·ªáu h√≥a n√∫t
        answerInput.addEventListener('input', () => {
          if (answerInput.value.trim() === '') {
            submitBtn.disabled = true; // ƒê·∫£m b·∫£o n√∫t b·ªã v√¥ hi·ªáu h√≥a khi input r·ªóng
          } else {
            submitBtn.disabled = false;
          }
        });


        answerInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            // Ch·ªâ g·ªçi handleAnswerSubmission n·∫øu n√∫t kh√¥ng b·ªã disabled (t·ª©c l√† input kh√¥ng r·ªóng)
            if (!submitBtn.disabled) {
              handleAnswerSubmission();
            }
          }
        });


        window.addEventListener('keydown', (e) => {
          // Ch·ªâ x·ª≠ l√Ω F5 ƒë·ªÉ reset khi m√†n h√¨nh b·ªã kh√≥a ƒëang hi·ªÉn th·ªã
          if (e.key === 'F5' && lockedScreen.style.display === 'flex') {
            e.preventDefault(); // NgƒÉn trang reload

            attemptsLeft = 4;
            errorMessage.textContent = '';
            attemptsMessage.textContent = '';
            answerInput.value = ''; // X√≥a gi√° tr·ªã
            lockedScreen.style.display = 'none';
            questionBox.style.display = 'block';
            answerInput.disabled = false; // K√≠ch ho·∫°t l·∫°i √¥ nh·∫≠p li·ªáu
            answerInput.focus();
            // K√≠ch ho·∫°t l·∫°i n√∫t tr·∫£ l·ªùi s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω t·ª± ƒë·ªông khi value c·ªßa input thay ƒë·ªïi (th√†nh r·ªóng)
            answerInput.dispatchEvent(new Event('input')); // K√≠ch ho·∫°t s·ª± ki·ªán input ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t

            // ƒê·∫£m b·∫£o d·ª´ng v√† x√≥a ph√°o hoa khi reset ho√†n to√†n
            if (fireworkInterval) {
              clearInterval(fireworkInterval);
              fireworkInterval = null;
            }
            if (successScreensaver) {
              successScreensaver.style.display = 'none';
              if (fireworksMusic) { // Stop fireworks music
                fireworksMusic.pause();
                fireworksMusic.currentTime = 0;
              }
              allowExitSuccessScreen = false; // ƒê·∫∑t l·∫°i c·ªù
              activeFireworkElements = []; // Clear all active fireworks
            }

          } else if (successScreensaver && successScreensaver.style.display === 'block' && allowExitSuccessScreen) { // Th√™m ƒëi·ªÅu ki·ªán c·ªù
            successScreensaver.style.display = 'none';
            if (fireworkInterval) {
              clearInterval(fireworkInterval);
              fireworkInterval = null;
            }
            if (fireworksMusic) { // Stop fireworks music
              fireworksMusic.pause();
              fireworksMusic.currentTime = 0;
            }
            if (mainBackgroundMusic) { // Stop main background music
              mainBackgroundMusic.pause();
              mainBackgroundMusic.currentTime = 0;
            }
            // NEW: Play main background music when success screensaver is exited
            if (mainBackgroundMusic) {
                console.log('Attempting to load and play main background music upon success screen exit...');
                mainBackgroundMusic.load();
                mainBackgroundMusic.play().then(() => {
                    console.log('Main background music started playing successfully after success screen exit.');
                }).catch(error => {
                    console.error('Error playing main background music on success screen exit:', error);
                });
            }
          }
        });


      } else {
        console.error('M·ªôt ho·∫∑c nhi·ªÅu ph·∫ßn t·ª≠ kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong DOM.');
      }
    });


    const bouncingImages = [];

    // H√†m ƒë·ªÉ ƒë·ªçc danh s√°ch ·∫£nh t·ª´ URL v√† t·∫£i tr∆∞·ªõc ch√∫ng
    async function loadImages() {
      try {
        console.log('B·∫Øt ƒë·∫ßu t·∫£i danh s√°ch ·∫£nh...');
        const response = await fetch('https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/list.txt');
        console.log('Response status:', response.status);
        const text = await response.text();
        console.log('Text nh·∫≠n ƒë∆∞·ª£c:', text);
        const imageUrls = text.split('\n').filter(url => url.trim() !== '');
        console.log('S·ªë l∆∞·ª£ng ·∫£nh t√¨m th·∫•y:', imageUrls.length);

        const promises = imageUrls.map(url => {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = url;
            img.onload = () => {
              bouncingImages.push(img); // L∆∞u tr·ªØ ƒë·ªëi t∆∞·ª£ng Image ƒë√£ t·∫£i
              resolve();
            };
            img.onerror = () => {
              console.error(`Failed to load image: ${url}`);
              reject();
            };
          });
        });

        await Promise.allSettled(promises); // Ch·ªù t·∫•t c·∫£ ·∫£nh ƒë∆∞·ª£c t·∫£i (ho·∫∑c th·∫•t b·∫°i)
        console.log('Ho√†n th√†nh t·∫£i ·∫£nh, s·ªë l∆∞·ª£ng ·∫£nh s·∫µn s√†ng:', bouncingImages.length);
      } catch (error) {
        console.error('Error loading images:', error);
      }
    }

    // New function for fireworks effect
    function startFireworksEffect() {
      if (fireworkInterval) {
        clearInterval(fireworkInterval); // Clear any existing interval
      }

      fireworkInterval = setInterval(() => {
        // NEW: Check if shuffled array is empty, if so, reshuffle
        if (shuffledSuccessScreenAssets.length === 0) {
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
            console.log('Shuffled success screen assets reloaded and reshuffled.');
        }

        // NEW: Get the next asset from the shuffled array
        if (shuffledSuccessScreenAssets.length === 0) {
            console.warn('No success screen assets available after reshuffling.');
            return; // Exit if no assets are available even after reshuffling (should not happen if successScreenAssets is populated)
        }
        const randomAsset = shuffledSuccessScreenAssets.shift(); // Get and remove the first element

        let newElement;
        let estimatedWidth, estimatedHeight;

        // NEW: Determine if the asset is an image or text
        const isImage = /\.(gif|jpe?g|png|webp)$/i.test(randomAsset);

        if (isImage) {
            newElement = document.createElement('img');
            newElement.classList.add('firework-gif'); // Reuse firework-gif class for styling images
            newElement.src = randomAsset;
            estimatedWidth = 150; // Use estimated GIF dimensions
            estimatedHeight = 150;
        } else {
            newElement = document.createElement('div');
            newElement.classList.add('success-bouncing-text'); // Use specific class for text
            newElement.textContent = randomAsset;
            estimatedWidth = 300; // Use estimated text dimensions
            estimatedHeight = 70;
        }

        // Find a non-overlapping position
        const position = findNonOverlappingPosition(estimatedWidth, estimatedHeight);

        newElement.style.left = `${position.x}px`;
        newElement.style.top = `${position.y}px`;

        successScreensaver.appendChild(newElement);

        // Add to active list
        const assetEntry = {
            domElement: newElement, // Store the created DOM element
            rect: { x: position.x, y: position.y, width: estimatedWidth, height: estimatedHeight }
        };
        activeFireworkElements.push(assetEntry);

        // Update exact dimensions once rendered for more accurate overlap checking
        // Use an event listener for images to get actual dimensions once loaded
        if (isImage) {
            newElement.onload = () => {
                assetEntry.rect.width = newElement.offsetWidth;
                assetEntry.rect.height = newElement.offsetHeight;
            };
        } else {
            // For text, offsetWidth/Height are usually available immediately after append
            setTimeout(() => {
                assetEntry.rect.width = newElement.offsetWidth;
                assetEntry.rect.height = newElement.offsetHeight;
            }, 0);
        }


        // Remove element and its position entry after its animation duration
        const animationDurationMs = 6 * 1000; // Match CSS animation duration (6s)
        setTimeout(() => {
            newElement.remove();
            // Remove from activeFireworkElements array
            const index = activeFireworkElements.indexOf(assetEntry);
            if (index > -1) {
                activeFireworkElements.splice(index, 1);
            }
        }, animationDurationMs);

      }, 600); // Create asset every 600ms
    }

    // New function to clear all fireworks assets
    function clearFireworks() {
      if (successScreensaver) {
        // NEW: Select and remove both text and image elements with their respective classes
        while (successScreensaver.querySelector('.success-bouncing-text')) {
          successScreensaver.querySelector('.success-bouncing-text').remove();
        }
        while (successScreensaver.querySelector('.firework-gif')) {
          successScreensaver.querySelector('.firework-gif').remove();
        }
      }
    }


    // G·ªçi h√†m loadImages khi trang ƒë∆∞·ª£c t·∫£i
    document.addEventListener('DOMContentLoaded', () => { // Removed 'async' from here
      console.log('DOM ƒë√£ ƒë∆∞·ª£c t·∫£i, b·∫Øt ƒë·∫ßu t·∫£i ·∫£nh v√† vƒÉn b·∫£n...');
      // NEW: Kick off combined assets loading in the background
      loadSuccessScreenAssets().then(() => console.log('Success screen assets finished loading in background.'));
      // Keep loading bouncing images for the song screensaver
      loadImages().then(() => console.log('Bouncing images finished loading in background.'));
      loadWallpaperImages().then(() => {
        console.log('Wallpaper images finished loading in background.');
        startBackgroundChange(); // Start background change only after wallpapers are loaded
      });

      console.log('Ho√†n th√†nh t·∫£i ·∫£nh'); // This log will now appear much faster
      // Ban ƒë·∫ßu v√¥ hi·ªáu h√≥a n√∫t submit n·∫øu input r·ªóng
      if (answerInput.value.trim() === '') {
        submitBtn.disabled = true;
      }
      // REMOVED: No longer calling startBackgroundChange directly here as it's chained to loadWallpaperImages
      // startBackgroundChange();
    });

    let currentImgIndex = 0;

    function showScreensaver(songUrl) {
      if (bouncingImages.length === 0) {
        console.error('No images loaded');
        return;
      }
      const screensaver = document.getElementById("screensaver");
      const bouncingImg = document.getElementById("bouncing-image");
      const audio = document.getElementById("myAudio");
      const source = document.getElementById("audio-source");

      if (animationInterval) {
        clearInterval(animationInterval);
      }

      screensaver.style.display = "flex";

      const randomIndex = Math.floor(Math.random() * bouncingImages.length);
      currentImgIndex = randomIndex;

      // Lo·∫°i b·ªè c√°c d√≤ng ·∫©n/hi·ªán ·∫£nh
      // bouncingImg.style.visibility = 'hidden';
      bouncingImg.src = bouncingImages[randomIndex].src;
      // setTimeout(() => {
      //     bouncingImg.style.visibility = 'visible';
      // }, 0);


      // X·ª≠ l√Ω audio an to√†n h∆°n
      try {

        if (mainBackgroundMusic) {
            mainBackgroundMusic.pause();
            mainBackgroundMusic.currentTime = 0;
            console.log('Main background music stopped due to song selection.');
        }
        
        audio.pause();
        audio.currentTime = 0;

        source.src = songUrl;
        audio.load();

        // Th√™m m·ªôt ch√∫t delay tr∆∞·ªõc khi play
        setTimeout(() => {
          audio.play().catch(error => {
            if (error.name !== 'AbortError') {
              console.log('Audio play error:', error);
            }
          });
        }, 100);
      } catch (error) {
        console.log('Audio handling error:', error);
      }

      screensaver.style.display = "block";

      let dx = 3;
      let dy = 2;
      let x = 100;
      let y = 100;

      animationInterval = setInterval(() => {
        const imgWidth = bouncingImg.clientWidth;
        const imgHeight = bouncingImg.clientHeight;
        const maxX = window.innerWidth - imgWidth;
        const maxY = window.innerHeight - imgHeight;

        x += dx;
        y += dy;

        if (x <= 0 || x >= maxX) {
          dx *= -1;
          switchImageRandom();
        }

        if (y <= 0 || y >= maxY) {
          dy *= -1;
          switchImageRandom();
        }

        bouncingImg.style.left = `${x}px`;
        bouncingImg.style.top = `${y}px`;
      }, 16);

      audio.onended = function() {
        screensaver.style.display = "none";
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }
        // NEW: Resume main background music after song ends
        if (mainBackgroundMusic) {
          mainBackgroundMusic.play().then(() => {
            console.log('Main background music resumed after song ended.');
          }).catch(error => {
            if (error.name === 'NotAllowedError') {
              console.warn('Autoplay prevented for main background music on song end. User interaction needed.');
            } else if (error.name === 'AbortError') {
              console.warn('Main background music play aborted on song end.');
            } else {
              console.error('Error resuming main background music on song end:', error);
            }
          });
        }
      };
    }

    function switchImageRandom() {
      const bouncingImg = document.getElementById("bouncing-image");
      if (!bouncingImg) return;

      let newIndex;
      do {
        newIndex = Math.floor(Math.random() * bouncingImages.length);
      } while (newIndex === currentImgIndex && bouncingImages.length > 1);

      currentImgIndex = newIndex;
      // Lo·∫°i b·ªè c√°c d√≤ng ·∫©n/hi·ªán ·∫£nh
      // bouncingImg.style.visibility = 'hidden';
      bouncingImg.src = bouncingImages[currentImgIndex].src;
      // setTimeout(() => {
      //     bouncingImg.style.visibility = 'visible';
      // }, 0);
    }

    document.addEventListener('keydown', function handleAnyKeyExitScreensaver(e) {
      const screensaver = document.getElementById("screensaver");
      if (screensaver && screensaver.style.display === "block") {
        screensaver.style.display = "none";
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }

        const audio = document.getElementById('myAudio');
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
        }
        // NEW: Play main background music if exiting screensaver by key press
        if (mainBackgroundMusic) {
            console.log('Attempting to load and play main background music upon screensaver exit...');
            mainBackgroundMusic.load(); // Ensure it's loaded
            mainBackgroundMusic.play().then(() => {
                console.log('Main background music started playing successfully after screensaver exit.');
            }).catch(error => {
                console.error('Error playing main background music on screensaver exit:', error);
            });
        }
      } else if (successScreensaver && successScreensaver.style.display === 'block' && allowExitSuccessScreen) { // Th√™m ƒëi·ªÅu ki·ªán c·ªù
            successScreensaver.style.display = 'none';
            if (fireworkInterval) {
              clearInterval(fireworkInterval);
              fireworkInterval = null;
            }
            if (fireworksMusic) { // Stop fireworks music
              fireworksMusic.pause();
              fireworksMusic.currentTime = 0;
            }
            if (mainBackgroundMusic) { // Stop main background music
              mainBackgroundMusic.pause();
              mainBackgroundMusic.currentTime = 0;
            }
            // NEW: Play main background music when success screensaver is exited
            if (mainBackgroundMusic) {
                console.log('Attempting to load and play main background music upon success screen exit...');
                mainBackgroundMusic.load();
                mainBackgroundMusic.play().then(() => {
                    console.log('Main background music started playing successfully after success screen exit.');
                }).catch(error => {
                    console.error('Error playing main background music on success screen exit:', error);
                });
            }
          }
    });

    // X·ª≠ l√Ω khi tab ·∫©n/hi·ªán ƒë·ªÉ d·ª´ng/kh·ªüi ƒë·ªông l·∫°i vi·ªác t·∫°o GIF ph√°o hoa
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Tab b·ªã ·∫©n, d·ª´ng vi·ªác t·∫°o GIF ph√°o hoa m·ªõi
        // Lo·∫°i b·ªè d√≤ng n√†y ƒë·ªÉ ph√°o hoa ti·∫øp t·ª•c sinh ra khi tab b·ªã ·∫©n
        // if (fireworkInterval) {
        //   clearInterval(fireworkInterval);
        //   fireworkInterval = null;
        // }
      } else {
        // Tab hi·ªÉn th·ªã tr·ªü l·∫°i, ti·∫øp t·ª•c t·∫°o GIF m·ªõi n·∫øu m√†n h√¨nh th√†nh c√¥ng ƒëang hi·ªÉn th·ªã
        if (successScreensaver && successScreensaver.style.display === 'block' && allowExitSuccessScreen) { // Th√™m ƒëi·ªÅu ki·ªán c·ªù
          startFireworksEffect();
        }
      }
    });

    // Function to change background image
    function changeBackgroundImage() {
        if (wallpaperImageUrls.length === 0) {
            console.warn('No wallpaper images loaded.');
            return;
        }
        currentBackgroundIndex = (currentBackgroundIndex + 1) % wallpaperImageUrls.length;
        body.style.backgroundImage = `url(${wallpaperImageUrls[currentBackgroundIndex]})`;
    }

    // Function to start automatic background change
    function startBackgroundChange() {
        if (backgroundChangeInterval) {
            clearInterval(backgroundChangeInterval);
        }
        // Thay ƒë·ªïi ·∫£nh n·ªÅn ngay l·∫≠p t·ª©c l·∫ßn ƒë·∫ßu
        changeBackgroundImage();
        // Sau ƒë√≥ thay ƒë·ªïi ·∫£nh n·ªÅn m·ªói 5 gi√¢y (ho·∫∑c th·ªùi gian b·∫°n mu·ªën)
        backgroundChangeInterval = setInterval(changeBackgroundImage, 5000); // Change every 5 seconds
    }

    // New function to load wallpaper images from example.txt
    async function loadWallpaperImages() {
        try {
            console.log('Attempting to load wallpaper image URLs from wallpaper.txt...');
            // T·∫°o m·ªôt timestamp ƒë·ªÉ ph√° cache
            const timestamp = new Date().getTime();
            // Corrected URL for wallpaper.txt with cache busting
            const response = await fetch(`https://raw.githubusercontent.com/gnid31/meo/main/wallpaper.txt?t=${timestamp}`);
            if (!response.ok) {
                console.error(`Failed to fetch wallpaper.txt: HTTP error! status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            wallpaperImageUrls = text.split('\n').filter(url => url.trim() !== '');

            // NEW: Preload images by creating Image objects
            const preloadPromises = wallpaperImageUrls.map(url => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = url;
                    img.onload = resolve;
                    img.onerror = () => {
                        console.warn(`Failed to preload wallpaper image: ${url}`);
                        resolve(); // Resolve even on error to not block Promise.all
                    };
                });
            });
            await Promise.allSettled(preloadPromises); // Wait for all images to attempt to load

            console.log('Successfully loaded and preloaded wallpaper images. Count:', wallpaperImageUrls.length);
            console.log('Wallpaper URLs:', wallpaperImageUrls);
        } catch (error) {
            console.error('Error loading wallpaper images from wallpaper.txt:', error);
            // Fallback to a default image or show an error
            body.style.backgroundImage = `url("C:/Users/ADMIN/Desktop/meomeo/wallpaper/e82e59a091fccfe88d581ef7dc56f070.jpg")`; // Fallback to a default if loading fails
        }
    }

    // NEW: Function to load all assets for the success screen from a single file
    async function loadSuccessScreenAssets() {
        try {
            console.log('Attempting to load success screen assets from assets.txt...');
            const timestamp = new Date().getTime(); // Cache busting
            const response = await fetch(`https://raw.githubusercontent.com/gnid31/meo/main/assets.txt?t=${timestamp}`);
            if (!response.ok) {
                console.error(`Failed to fetch assets.txt: HTTP error! status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            successScreenAssets = text.split('\n').map(asset => asset.trim()).filter(asset => asset !== '');
            // Initialize and shuffle the shuffled array
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
            console.log('Successfully loaded and shuffled success screen assets. Count:', successScreenAssets.length);
            console.log('Loaded assets:', successScreenAssets);
        } catch (error) {
            console.error('Error loading success screen assets from assets.txt:', error);
            // Fallback to default assets if loading fails
            successScreenAssets = ["Ch√∫c m·ª´ng!", "https://raw.githubusercontent.com/gnid31/meo/refs/heads/main/gif/box.gif"];
            shuffledSuccessScreenAssets = shuffleArray([...successScreenAssets]);
        }
    }

  </script>
  <div id="screensaver">
    <div id="exit-hint">Press any key to exit (tr·ª´ n√∫t Space)</div>
    <img id="bouncing-image" src="" alt="Bouncing" />
  </div>



</body>

</html>